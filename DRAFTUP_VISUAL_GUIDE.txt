================================================================================
  DRAFTUP KBITE: VISUAL DESIGN GUIDE
  Alternative Index Organization for draftup_project
================================================================================

DOCUMENT MAP
============

  README_DRAFTUP_DESIGN.md ← START HERE
         ↓
         ├─→ DRAFTUP_DESIGN_SUMMARY.md (Executive Overview, 10 min)
         │         ↓
         ├─→ DRAFTUP_QUICK_REFERENCE.md (Daily Reference Card)
         │         ↓
         ├─→ DRAFTUP_KBITE_ALTERNATIVE_INDEX.md (Full Design Spec)
         │         ↓
         ├─→ DRAFTUP_HIDDEN_PATTERNS.md (Pattern Deep Dive)
         │         ↓
         └─→ DRAFTUP_IMPLEMENTATION_GUIDE.md (How to Build It)

================================================================================

THE 5 CONCEPT CLUSTERS
======================

         E: Development Workflow
              ↓
         A: ECS Architecture
         ↙           ↘
    C: Parametric   B: Rendering
         ↘           ↙
         D: Assembly

FLOW: Architecture → Entities → Parameters & Rendering → Assembly → Testing


CLUSTER A: ECS ARCHITECTURE
  │
  ├─ Concepts: Triple-ID, Dirty Flag, MainActor
  ├─ Resources: DraftUpMvpSummary, bfb_bwain, DraftUpProject
  └─ Triggers: entity, UUID, triple-id, component, dirty flag


CLUSTER B: RENDERING
  │
  ├─ Concepts: CSG Mesh, IBL Lighting, Observable
  ├─ Resources: reference_build, DraftUpMvpSummary
  └─ Triggers: mesh, CSG, IBL, rendering, geometry


CLUSTER C: PARAMETRIC DESIGN
  │
  ├─ Concepts: Expression Parsing, Constraints, Parameters
  ├─ Resources: DraftUpProject, dec_prompts, jan_prompts
  └─ Triggers: expression, parameter, constraint, formula


CLUSTER D: ASSEMBLY
  │
  ├─ Concepts: Feature Composition, Joinery, Validation
  ├─ Resources: dec_prompts, jan_prompts, initial_project_prompts
  └─ Triggers: assembly, rabbet, groove, compose, integrate


CLUSTER E: WORKFLOW
  │
  ├─ Concepts: Architecture Review, Feature Dev Stages, Testing
  ├─ Resources: initial_project_prompts, jan_prompts, bfb_bwain
  └─ Triggers: architecture, test, workflow, @globalActor, validation

================================================================================

THE 6 USAGE PATTERNS
====================

Pattern 1: BOOTSTRAP NEW FEATURE
  Workflow: E (review) → A (entities) → C (params) → B (render) → D (assemble) → E (test)
  When: Starting a new feature
  Triggers: "new feature", "feature development", "starting feature"

Pattern 2: DEBUG ENTITY/SCENE ISSUES
  Workflow: A (UUID check) → B (dirty flag check)
  When: Entity not showing, rendering problems
  Triggers: "entity not showing", "UUID mismatch", "rendering problem"

Pattern 3: IMPLEMENT MESH GENERATION
  Workflow: B (CSG strategy) → A (cache handling) → B (IBL)
  When: Building mesh operations
  Triggers: "mesh caching", "CSG", "geometry generation"

Pattern 4: RESOLVE RACE CONDITIONS
  Workflow: A (UUID store) → E (MainActor safety) → E (testing)
  When: Async/concurrent access problems
  Triggers: "race condition", "MainActor", "async safety"

Pattern 5: ASSEMBLE FEATURES
  Workflow: D (composition) → E (validation) → E (testing)
  When: Combining multiple features
  Triggers: "assembly", "rabbet", "groove", "integrate"

Pattern 6: OPTIMIZE MESH CACHE
  Workflow: E (measure frequency) → A (dirty flag) → B (regen) → B (IBL)
  When: Performance optimization needed
  Triggers: "mesh cache", "optimization", "performance"

================================================================================

THE 10 HIDDEN PATTERNS
======================

1. UUID/DIRTY FLAG COUPLING (70% of scenarios)
   Cannot troubleshoot one without the other
   Always pair activation: UUID ↔ Dirty Flag

2. RENDERING PIPELINE INVERSION
   Pull-based (not push-based like game engines)
   Reference patterns: reference_build → concepts → practical

3. FEATURE-DEV WORKFLOW GRADIENT
   3 stages: Architecture Review → Feature Dev → Testing
   Always follow stage order, never skip

4. DEPENDENCY CONE
   Specific order: E→A→{B,C}→D→E
   Prevents conceptual gaps and missing prerequisites

5. MAINACTOR AMPLIFICATION
   High in A (95%) and E (85%), Low in C (15%) and D (20%)
   Contextualize MainActor triggers to cluster

6. PERFORMANCE CHAIN
   Frequency→Flag→Regen→IBL→FPS
   Start with frequency analysis, not algorithm optimization

7. ASSEMBLY COMPLEXITY GRADIENT
   4 levels: Independent → Sequential → Mutual → Circular
   Match resource to complexity level

8. OBSERVABLE BINDING PATTERN
   State management spine across all clusters
   Key cross-cutting concern

9. UUID STORE EFFICIENCY PARADOX
   Triple-ID solves persistence/async reconciliation
   Not over-engineering, solving real problem

10. MISSING ABSTRACTION
    Entity state machine gap in resources
    Opportunity for new resource

================================================================================

ANTI-TRIGGERS (PREVENT FALSE POSITIVES)
=========================================

❌ DO NOT ACTIVATE ON:

Over-Broad Terms:
  • "swift" (language, not framework)
  • "code" (too generic)
  • "bug" (generic debugging)
  • "performance" (vague optimization)

External Systems:
  • "visionOS" alone (use with DraftUp context)
  • "SwiftUI" alone (use with DraftUp context)
  • "CloudKit" (different kbite)

Process-Level:
  • "git workflow" (use GMCC docs)
  • "code review" (management context)
  • "testing" alone (use "DraftUp testing")

Conceptually Distant:
  • "distributed systems" (wrong scale)
  • "networking" (not DraftUp concern)
  • "database schema" (generic data)

✅ DO ACTIVATE ON:

• triple-id (specific to DraftUp)
• dirty flag (specific pattern)
• CSG (specific to rendering)
• expression parser (specific to parametric)
• rabbet groove (specific to assembly)
• entity UUID + context (specific domain)

================================================================================

THE 6 SYMPTOM-BASED TRIGGER GROUPS
===================================

GROUP 1: "THE TRIPLE-ID PROBLEM"
  Confidence: 95%
  Symptoms: Entity identity confusion, UUID sync failures
  Keywords: triple-id, UUID store, entity identity, ID mapping
  Go To: bfb_bwain → DraftUpMvpSummary → DraftUpProject

GROUP 2: "THE DIRTY FLAG DANCE"
  Confidence: 92%
  Symptoms: Rendering not updating, stale views, change detection
  Keywords: dirty flag, change detection, observable not firing, stale render
  Go To: DraftUpMvpSummary → reference_build → DraftUpProject

GROUP 3: "THE PARAMETRIC EXPRESSION TANGO"
  Confidence: 88%
  Symptoms: Expression parsing, constraint issues, formula evaluation
  Keywords: expression parsing, constraint, formula, parameter binding
  Go To: DraftUpProject → dec_prompts → jan_prompts

GROUP 4: "THE ASYNC MAINACTOR MAZE"
  Confidence: 94%
  Symptoms: Race conditions, MainActor violations, concurrent access
  Keywords: race condition, MainActor, concurrent, @globalActor, actor isolation
  Go To: bfb_bwain → jan_prompts → DraftUpMvpSummary

GROUP 5: "THE ASSEMBLY ALIGNMENT"
  Confidence: 90%
  Symptoms: Feature composition, integration issues, joinery validation
  Keywords: assembly, feature integration, rabbet groove, assembly test, alignment
  Go To: dec_prompts → jan_prompts → initial_project_prompts

GROUP 6: "THE MESH CACHE QUEST"
  Confidence: 93%
  Symptoms: Geometry generation, caching strategy, rendering performance
  Keywords: mesh caching, CSG, cache invalidation, geometry optimization
  Go To: DraftUpMvpSummary → reference_build → DraftUpProject

================================================================================

QUICK DECISION MATRIX
====================

Question                              | Pattern            | Primary Resource       | Secondary
--------------------------------------|-------------------|------------------------|------------------
"How do entities work?"               | Cluster-A-Intro   | DraftUpMvpSummary      | bfb_bwain
"Why isn't mesh showing?"             | Dirty-Flag-Dance  | DraftUpMvpSummary      | reference_build
"How do I cache meshes?"              | Mesh-Cache-Quest  | DraftUpMvpSummary      | reference_build
"How do I make parameters?"           | Param-Expression  | DraftUpProject         | dec_prompts
"How do I assemble features?"         | Assembly-Align    | dec_prompts            | jan_prompts
"Race condition in entities?"         | MainActor-Maze    | bfb_bwain              | jan_prompts
"How should I structure features?"    | Bootstrap-Path-E  | initial_project_prompts| jan_prompts
"How do I test assembly?"             | Assembly-Align-E  | jan_prompts            | initial_project_prompts

================================================================================

RESOURCE QUICK-REFERENCE
========================

DraftUpMvpSummary
  ├─ Best For: Architecture overview, triple-ID, dirty flag
  ├─ Weakness: High-level, not implementation details
  ├─ Clusters: A, B
  └─ Confidence: 95

reference_build
  ├─ Best For: VisionOS patterns, IBL, Observable, CSG caching
  ├─ Weakness: Platform-specific, not all patterns
  ├─ Clusters: B, E
  └─ Confidence: 90

DraftUpProject
  ├─ Best For: Practical examples, UUID store, expression parser
  ├─ Weakness: Project-specific, may not generalize
  ├─ Clusters: A, C
  └─ Confidence: 85

dec_prompts
  ├─ Best For: Feature dev details, rabbet/groove, assembly
  ├─ Weakness: December-specific, older patterns
  ├─ Clusters: D, E
  └─ Confidence: 80

jan_prompts
  ├─ Best For: Testing patterns, GM-CDE workflow, @globalActor
  ├─ Weakness: January-specific, newer patterns
  ├─ Clusters: E, A
  └─ Confidence: 85

initial_project_prompts
  ├─ Best For: Architecture review, acknowledgment protocol
  ├─ Weakness: Abstract, not code-focused
  ├─ Clusters: E
  └─ Confidence: 80

bfb_bwain
  ├─ Best For: UUID race conditions, Actor patterns, async safety
  ├─ Weakness: Deep-dive only, not overview
  ├─ Clusters: A, E
  └─ Confidence: 94

================================================================================

IMPLEMENTATION TIMELINE
======================

PHASE 1: LIGHTWEIGHT (2-3 hours)
├─ Create KBITE_CLUSTERS.md
├─ Create KBITE_PATTERNS.md
├─ Create KBITE_ANTI_TRIGGERS.md
└─ Update existing trigger logic
    Result: 50-70% false-positive reduction

PHASE 2: FULL (6-8 hours)
├─ Create KBITE_DEPENDENCY_GRAPH.md
├─ Create KBITE_TRIGGER_GROUPS.md
├─ Create resources.json metadata
├─ Create KBITE_DECISION_MATRIX.md
└─ Update KBITE_RELATIONSHIPS.md
    Result: All patterns captured, optimal activation

PHASE 3: INFRASTRUCTURE (4-6 hours, OPTIONAL)
├─ Reorganize resource directories
├─ Create cluster manifests
├─ Build search index
└─ Integration testing
    Result: Scalable infrastructure, advanced features

================================================================================

SUCCESS METRICS
===============

Phase 1 Success:
  ✓ Developers use clusters to understand organization
  ✓ Anti-triggers reduce noise (-70% false positives)
  ✓ Usage patterns guide feature development (+30% confidence)

Phase 2 Success:
  ✓ Dependency graph reveals hidden connections
  ✓ Trigger groups accelerate debugging (-50% time)
  ✓ Decision matrix covers 90%+ common questions

Phase 3 Success (Optional):
  ✓ Cluster structure scales to 10+ future clusters
  ✓ Search performance <100ms for complex queries
  ✓ New developers onboard 2x faster

================================================================================

NEXT STEPS
==========

1. READ: README_DRAFTUP_DESIGN.md (this directory)
2. REVIEW: DRAFTUP_DESIGN_SUMMARY.md (10 min overview)
3. DECIDE: Level 1, 2, or 3 implementation
4. PLAN: Use DRAFTUP_IMPLEMENTATION_GUIDE.md
5. EXECUTE: Start Phase 1 (1.5 hours minimum viable)
6. ITERATE: Collect feedback, refine patterns

================================================================================

FILES INCLUDED
==============

✓ README_DRAFTUP_DESIGN.md              ← Master guide (read first)
✓ DRAFTUP_DESIGN_SUMMARY.md             ← Executive overview
✓ DRAFTUP_QUICK_REFERENCE.md            ← One-page reference
✓ DRAFTUP_KBITE_ALTERNATIVE_INDEX.md    ← Full specification
✓ DRAFTUP_HIDDEN_PATTERNS.md            ← Pattern analysis
✓ DRAFTUP_IMPLEMENTATION_GUIDE.md       ← Step-by-step guide
✓ DRAFTUP_VISUAL_GUIDE.txt              ← This file

Total: 3,100+ lines of specification

================================================================================

DESIGN PHILOSOPHY
=================

TRADITIONAL APPROACH:
  "Where is the information?"
  → Tier-based organization (primary, secondary)
  → Static reference structure
  → Keyword matching

THIS DESIGN:
  "What is the developer trying to do?"
  → Concept-cluster organization
  → Dynamic reasoning about context
  → Usage-pattern activation

TRANSFORMATION:
  Kbites shift from PASSIVE REFERENCE to ACTIVE GUIDANCE

================================================================================

FOR FORGE BUILD SUPPORT
=======================

When building DraftUp during "forge up":

1. Check Architecture First (Cluster E)
   └─ Understand design decisions

2. Understand Entity System (Cluster A)
   └─ Core to everything else

3. Implement in Dependency Cone Order
   └─ E → A → {B,C} → D → E

4. Use Symptom Groups When Stuck
   └─ Not just keyword matching

5. Check Anti-Triggers
   └─ Avoid unrelated documentation

6. Reference Dependencies
   └─ Use cone to order learning

This keeps knowledge organized BY HOW IT'S ACTUALLY USED.

================================================================================

                           READY TO IMPLEMENT
                         Design is complete. Start
                    with README_DRAFTUP_DESIGN.md

================================================================================
